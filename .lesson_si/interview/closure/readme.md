# 介绍下闭包

- 一句话介绍概念
closure是js的重要语法特性,能访问**自由变量**的函数就叫闭包,
当一个内部函数访问了它所在的外部函数作用域中的变量,即使外部函数已经执行完毕
这些变量任然停留在内存中,像在背包里一样,供内部还可以调用,这种机制叫闭包。

你不知道的javascript 闭包 = 函数 + 词法作用域  (本质)

形成条件: 函数嵌套函数。内部函数可以在外界访问(通过返回或挂载在全局)
    立即执行函数,块级作用域+定时器
    
- 底层原理
    词法作用域(Lexical Scope)
    Javascript在定义函数时,就确定了函数能访问哪些变量(作用域在申明阶段就决定)
    作用域链(Scope Chain) 内部函数查找变量时会沿着作用域链条
    向上查找外层变量
    变量持久优化:由于闭包函数依然引用自由变量,JS 引擎的GC(Garbage Collection)认为
    这些外部变量还在用,所以不会销毁,导致变量的内存泄漏


- 模型图



- 业务场景

    - 数据私有化
        封装类函数的复杂性
    - 防抖节流
    - 循环绑定事件
    ```js
    for(var i=0;i<3;i++){
        setTimeout(()=>{
            console.log(i);
        },100)
    }
    var -> let 闭包
    立即执行函数 IIFE
    //把var改成let就闭包了
    ```

    - 缓存记忆优化
    ```js
    function memoized(fn){
        const cache ={};
        return function(key){
            if(cache[key])return cache[key];
            const result = fn(key);
            cache[key] = result;
            return result;
        }
    }
    ```
    - 柯理化函数
    一个接受多个参数的函数,转换为一系列只接受一个参数的函数链

    - 偏函数...

## 总结

闭包是函数与其外部词法作用域的组合,它让函数在外部作用域执行完后依然能
访问里面的变量。本质是作用域链导致变量持久化,在数据中常用于数据私有化
防抖/节流 事件绑定,缓存优化等。

我在项目中经常用闭包减少全局变量污染但也注意可能带来内存泄漏,不需要时
手动释放引用

## setTimeout  里的回调函数是闭包吗 穷追猛打
从定义上说,setTimeout的回调一般会形成闭包。因为它在创建的时候捕获了外层函数的变量
即时外层函数执行借宿,变量依旧可访问。

但严格来说,setTimeout的回调函数本身不是闭包,因为闭包的本质是函数+词法作用域的绑定
是否是闭包,取决于回调是否调用自由变量,而不是setTimeout API,

比如在循环定时器时,用let 申明块级作用域或IIFE 闭包定时器回调,是闭包
